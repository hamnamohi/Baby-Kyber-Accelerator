$version Generated by VerilatedVcd $end
$timescale 1ps $end
 $scope module TOP $end
  $var wire 1 C clk $end
  $var wire 1 D rst_n $end
  $var wire 1 E enable $end
  $var wire 32 F secret_key[0][0] [31:0] $end
  $var wire 32 G secret_key[0][1] [31:0] $end
  $var wire 32 H secret_key[0][2] [31:0] $end
  $var wire 32 I secret_key[0][3] [31:0] $end
  $var wire 32 J secret_key[1][0] [31:0] $end
  $var wire 32 K secret_key[1][1] [31:0] $end
  $var wire 32 L secret_key[1][2] [31:0] $end
  $var wire 32 M secret_key[1][3] [31:0] $end
  $var wire 32 N ciphertext[0][0][0] [31:0] $end
  $var wire 32 O ciphertext[0][0][1] [31:0] $end
  $var wire 32 P ciphertext[0][0][2] [31:0] $end
  $var wire 32 Q ciphertext[0][0][3] [31:0] $end
  $var wire 32 R ciphertext[0][1][0] [31:0] $end
  $var wire 32 S ciphertext[0][1][1] [31:0] $end
  $var wire 32 T ciphertext[0][1][2] [31:0] $end
  $var wire 32 U ciphertext[0][1][3] [31:0] $end
  $var wire 32 V ciphertext[1][0][0] [31:0] $end
  $var wire 32 W ciphertext[1][0][1] [31:0] $end
  $var wire 32 X ciphertext[1][0][2] [31:0] $end
  $var wire 32 Y ciphertext[1][0][3] [31:0] $end
  $var wire 32 Z ciphertext[1][1][0] [31:0] $end
  $var wire 32 [ ciphertext[1][1][1] [31:0] $end
  $var wire 32 \ ciphertext[1][1][2] [31:0] $end
  $var wire 32 ] ciphertext[1][1][3] [31:0] $end
  $var wire 4 ^ m_b [3:0] $end
  $var wire 4 _ decimal_value [3:0] $end
  $scope module Decrypt $end
   $var wire 1 C clk $end
   $var wire 1 D rst_n $end
   $var wire 1 E enable $end
   $var wire 32 F secret_key[0][0] [31:0] $end
   $var wire 32 G secret_key[0][1] [31:0] $end
   $var wire 32 H secret_key[0][2] [31:0] $end
   $var wire 32 I secret_key[0][3] [31:0] $end
   $var wire 32 J secret_key[1][0] [31:0] $end
   $var wire 32 K secret_key[1][1] [31:0] $end
   $var wire 32 L secret_key[1][2] [31:0] $end
   $var wire 32 M secret_key[1][3] [31:0] $end
   $var wire 32 N ciphertext[0][0][0] [31:0] $end
   $var wire 32 O ciphertext[0][0][1] [31:0] $end
   $var wire 32 P ciphertext[0][0][2] [31:0] $end
   $var wire 32 Q ciphertext[0][0][3] [31:0] $end
   $var wire 32 R ciphertext[0][1][0] [31:0] $end
   $var wire 32 S ciphertext[0][1][1] [31:0] $end
   $var wire 32 T ciphertext[0][1][2] [31:0] $end
   $var wire 32 U ciphertext[0][1][3] [31:0] $end
   $var wire 32 V ciphertext[1][0][0] [31:0] $end
   $var wire 32 W ciphertext[1][0][1] [31:0] $end
   $var wire 32 X ciphertext[1][0][2] [31:0] $end
   $var wire 32 Y ciphertext[1][0][3] [31:0] $end
   $var wire 32 Z ciphertext[1][1][0] [31:0] $end
   $var wire 32 [ ciphertext[1][1][1] [31:0] $end
   $var wire 32 \ ciphertext[1][1][2] [31:0] $end
   $var wire 32 ] ciphertext[1][1][3] [31:0] $end
   $var wire 4 ^ m_b [3:0] $end
   $var wire 4 _ decimal_value [3:0] $end
   $var wire 32 d Q [31:0] $end
   $var wire 32 ; poly_out0[0] [31:0] $end
   $var wire 32 < poly_out0[1] [31:0] $end
   $var wire 32 = poly_out0[2] [31:0] $end
   $var wire 32 > poly_out0[3] [31:0] $end
   $var wire 32 ? poly_out1[0] [31:0] $end
   $var wire 32 @ poly_out1[1] [31:0] $end
   $var wire 32 A poly_out1[2] [31:0] $end
   $var wire 32 B poly_out1[3] [31:0] $end
   $var wire 32 ` temp_m_n[0] [31:0] $end
   $var wire 32 a temp_m_n[1] [31:0] $end
   $var wire 32 b temp_m_n[2] [31:0] $end
   $var wire 32 c temp_m_n[3] [31:0] $end
   $scope module poly_mult1 $end
    $var wire 1 C clk $end
    $var wire 1 D rst_n $end
    $var wire 1 E enable $end
    $var wire 32 # polynomial1[0] [31:0] $end
    $var wire 32 $ polynomial1[1] [31:0] $end
    $var wire 32 % polynomial1[2] [31:0] $end
    $var wire 32 & polynomial1[3] [31:0] $end
    $var wire 32 ' polynomial2[0] [31:0] $end
    $var wire 32 ( polynomial2[1] [31:0] $end
    $var wire 32 ) polynomial2[2] [31:0] $end
    $var wire 32 * polynomial2[3] [31:0] $end
    $var wire 32 ; polynomial_out[0] [31:0] $end
    $var wire 32 < polynomial_out[1] [31:0] $end
    $var wire 32 = polynomial_out[2] [31:0] $end
    $var wire 32 > polynomial_out[3] [31:0] $end
    $var wire 32 + temp_result[0] [31:0] $end
    $var wire 32 , temp_result[1] [31:0] $end
    $var wire 32 - temp_result[2] [31:0] $end
    $var wire 32 . temp_result[3] [31:0] $end
    $scope module unnamedblk1 $end
     $var wire 32 e k [31:0] $end
    $upscope $end
    $scope module unnamedblk2 $end
     $var wire 32 e i [31:0] $end
     $scope module unnamedblk3 $end
      $var wire 32 f j [31:0] $end
     $upscope $end
    $upscope $end
    $scope module unnamedblk4 $end
     $var wire 32 e a [31:0] $end
     $scope module unnamedblk5 $end
      $var wire 32 e b [31:0] $end
     $upscope $end
    $upscope $end
    $scope module unnamedblk6 $end
     $var wire 32 e k [31:0] $end
    $upscope $end
   $upscope $end
   $scope module poly_mult2 $end
    $var wire 1 C clk $end
    $var wire 1 D rst_n $end
    $var wire 1 E enable $end
    $var wire 32 / polynomial1[0] [31:0] $end
    $var wire 32 0 polynomial1[1] [31:0] $end
    $var wire 32 1 polynomial1[2] [31:0] $end
    $var wire 32 2 polynomial1[3] [31:0] $end
    $var wire 32 3 polynomial2[0] [31:0] $end
    $var wire 32 4 polynomial2[1] [31:0] $end
    $var wire 32 5 polynomial2[2] [31:0] $end
    $var wire 32 6 polynomial2[3] [31:0] $end
    $var wire 32 ? polynomial_out[0] [31:0] $end
    $var wire 32 @ polynomial_out[1] [31:0] $end
    $var wire 32 A polynomial_out[2] [31:0] $end
    $var wire 32 B polynomial_out[3] [31:0] $end
    $var wire 32 7 temp_result[0] [31:0] $end
    $var wire 32 8 temp_result[1] [31:0] $end
    $var wire 32 9 temp_result[2] [31:0] $end
    $var wire 32 : temp_result[3] [31:0] $end
    $scope module unnamedblk1 $end
     $var wire 32 e k [31:0] $end
    $upscope $end
    $scope module unnamedblk2 $end
     $var wire 32 e i [31:0] $end
     $scope module unnamedblk3 $end
      $var wire 32 f j [31:0] $end
     $upscope $end
    $upscope $end
    $scope module unnamedblk4 $end
     $var wire 32 e a [31:0] $end
     $scope module unnamedblk5 $end
      $var wire 32 e b [31:0] $end
     $upscope $end
    $upscope $end
    $scope module unnamedblk6 $end
     $var wire 32 e k [31:0] $end
    $upscope $end
   $upscope $end
   $scope module unnamedblk1 $end
    $var wire 32 e i [31:0] $end
   $upscope $end
   $scope module unnamedblk2 $end
    $var wire 32 e i [31:0] $end
   $upscope $end
   $scope module unnamedblk3 $end
    $var wire 32 e i [31:0] $end
   $upscope $end
  $upscope $end
 $upscope $end
$enddefinitions $end


#0
b00000000000000000000000000000111 #
b00000000000000000000000000010000 $
b00000000000000000000000000010000 %
b00000000000000000000000000000001 &
b11111111111111111111111111111111 '
b00000000000000000000000000000001 (
b11111111111111111111111111111111 )
b00000000000000000000000000000000 *
b00000000000000000000000000001000 +
b00000000000000000000000000001001 ,
b00000000000000000000000000001010 -
b00000000000000000000000000010000 .
b00000000000000000000000000001110 /
b00000000000000000000000000001001 0
b00000000000000000000000000010000 1
b00000000000000000000000000001110 2
b00000000000000000000000000000000 3
b00000000000000000000000000000000 4
b11111111111111111111111111111111 5
b00000000000000000000000000000001 6
b00000000000000000000000000000111 7
b00000000000000000000000000001111 8
b00000000000000000000000000000110 9
b00000000000000000000000000000101 :
b00000000000000000000000000000000 ;
b00000000000000000000000000000000 <
b00000000000000000000000000000000 =
b00000000000000000000000000000000 >
b00000000000000000000000000000000 ?
b00000000000000000000000000000000 @
b00000000000000000000000000000000 A
b00000000000000000000000000000000 B
0C
0D
0E
b11111111111111111111111111111111 F
b00000000000000000000000000000001 G
b11111111111111111111111111111111 H
b00000000000000000000000000000000 I
b00000000000000000000000000000000 J
b00000000000000000000000000000000 K
b11111111111111111111111111111111 L
b00000000000000000000000000000001 M
b00000000000000000000000000000111 N
b00000000000000000000000000010000 O
b00000000000000000000000000010000 P
b00000000000000000000000000000001 Q
b00000000000000000000000000001110 R
b00000000000000000000000000001001 S
b00000000000000000000000000010000 T
b00000000000000000000000000001110 U
b00000000000000000000000000001111 V
b00000000000000000000000000001000 W
b00000000000000000000000000010000 X
b00000000000000000000000000001101 Y
b00000000000000000000000000000000 Z
b00000000000000000000000000000000 [
b00000000000000000000000000000000 \
b00000000000000000000000000000000 ]
b1010 ^
b1010 _
b00000000000000000000000000000000 `
b00000000000000000000000000001001 a
b00000000000000000000000000000000 b
b00000000000000000000000000001001 c
b00000000000000000000000000010001 d
b00000000000000000000000000000100 e
b00000000000000000000000000000001 f
#1
1D
#2
b00000000000000000000000000001000 ;
b00000000000000000000000000001001 <
b00000000000000000000000000001010 =
b00000000000000000000000000010000 >
b00000000000000000000000000000111 ?
b00000000000000000000000000001111 @
b00000000000000000000000000000110 A
b00000000000000000000000000000101 B
1C
1E
b1000 ^
b1000 _
b00000000000000000000000000000000 a
#3
0C
#4
1C
#5
0C
#6
1C
#7
0C
#8
1C
#9
0C
#10
1C
#11
0C
